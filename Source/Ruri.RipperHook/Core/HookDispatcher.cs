using System;
using System.Reflection;
using System.Collections.Generic;
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.IO.Endian;
using AssetRipper.SourceGenerated;
using AssetRipper.Primitives;

namespace Ruri.RipperHook.Core
{
    public static class HookDispatcher
    {
        public delegate void ReadReleaseDelegate(object asset, ref EndianSpanReader reader);

        private static readonly Dictionary<Type, HookInfo> _genericHookCache = new();

        private class HookInfo
        {
            public MethodInfo? CreateMethod;
            public UnityVersion TargetVersion;
            public ReadReleaseDelegate? Callback;
            public IUnityObjectBase? DummyInstance; // Optimization: Reuse dummy if thread-safe or created per call
        }

        public static void Register(Type sourceType, MethodInfo? createMethod, UnityVersion targetVersion, ReadReleaseDelegate? callback)
        {
            _genericHookCache[sourceType] = new HookInfo
            {
                CreateMethod = createMethod,
                TargetVersion = targetVersion,
                Callback = callback
            };
        }

        public static void Universal_ReadRelease(object asset, ref EndianSpanReader reader)
        {
            var type = asset.GetType();

            if (!_genericHookCache.TryGetValue(type, out var hookInfo))
            {
                throw new InvalidOperationException($"[RipperHook] Generic hook called for unregistered type {type.FullName}");
            }

            // 1. Priority: Custom Callback
            if (hookInfo.Callback != null)
            {
                hookInfo.Callback(asset, ref reader);
                return;
            }

            // 2. Standard Flow: Create Ruri Dummy -> Read -> Deep Copy back
            var realThis = (IUnityObjectBase)asset;

            if (hookInfo.CreateMethod == null)
                throw new InvalidOperationException($"[RipperHook] Create method is null for {type.Name} and no callback provided.");

            try
            {
                // Create dummy object (generated by Ruri Project)
                // Invoke "Create" static method
                var dummyThis = (IUnityObjectBase)hookInfo.CreateMethod.Invoke(null, new object[] { realThis.AssetInfo, hookInfo.TargetVersion })!;

                // Read data using Ruri's logic
                dummyThis.ReadRelease(ref reader);

                // Copy data back to the real AssetRipper object
                ReflectionExtensions.ClassDeepCopy(dummyThis, realThis);
            }
            catch (Exception ex)
            {
                 throw new Exception($"[RipperHook] Error processing {type.Name}: {ex.Message}", ex);
            }
        }
    }
}
